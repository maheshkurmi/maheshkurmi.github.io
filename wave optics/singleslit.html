<!doctype html>
<html>
<head>
    <title>Single Slit Diffraction</title>
    <style>

        *{
            margin: 0; /* Vorgaben für Außenabstand löschen */
            padding: 0; /* Vorgaben für Innenabstand löschen */
        }

        /* Überschriften, Absätze, Listen */

        h1, h2, h3, h4, p, ol, ul, dl {
            margin: 10px 20px 10px 20px; /* Außenabstand */
        }

        /* Einzelne Listeneinträge */

        li {
            margin-left: 30px; /* Außenabstand links */
        }

        /* Überschrift Definitionsliste */

        dt {
            margin-bottom: 8px; /* Außenabstand unten */
            font-size: 18px; /* Schrifthöhe */
            font-weight: bold; /* Fettdruck */
        }

        /* Eintrag Definitionsliste */

        dd {
            margin-bottom: 25px;
        }

        /* Seiteninhalt */

        body {
            background-color: white; /* Hintergrundfarbe */
            font-family: Arial, Helvetica, sans-serif; /* Serifenlose Schrift */
            font-size: 16px; /* Schrifthöhe */
            font-weight: normal; /* Kein Fettdruck */
        }

        /* Überschriften 1. Ordnung */

        h1 {
           // background-color: yellow; /* Hintergrundfarbe */
           // border: 10px solid blue; /* Rand */
            padding: 5px; /* Innenabstand */
            text-align: center; /* Text zentriert */
            font-size: 24px; /* Schrifthöhe */
            font-weight: bold; /* Fettdruck */
        }

        /* Absätze */

        p {
            line-height: 1.3; /* Zeilenabstand */
        }

        /* Ungeordnete und geordnete Listen */

        ul, ol {
            line-height: 1.4; /* Zeilenabstand */
        }

        /* Hervorhebung von Begriffen */

        em.Begriff {
            font-style: normal; /* Normale Schrift (nicht kursiv) */
            color: blue; /* Schriftfarbe */
        }

        /* Trennlinie */

        hr.Trennlinie {
            margin: 20px auto 20px auto; /* Außenrand */
            width: 40%; /* Breite */
            border-bottom: solid thin blue; /* Linie durchgezogen, dünn, blau */
        }

        /* Noch nicht besuchte Links */

        a:link {
            color: blue; /* Farbe blau */
        }

        /* Schon besuchte Links */

        a:visited {
            color: blue; /* Farbe blau */
        }

        /* Mauszeiger auf Links */

        a:hover {
            color: #ff0000; /* Farbe rot */
            text-decoration: underline; /* Text unterstrichen */
        }

        /* Inline-Elemente ohne automatischen Zeilenumbruch */

        span.nobr {
            white-space: nowrap; /* Kein automatischer Zeilenumbruch */
        }

        /*-------------------------------------------------------------------------------------------------
          Vorgaben für spezielle Bereiche
          -------------------------------------------------------------------------------------------------*/

        /* Eingerahmte Formel */

        span.Formel {
            background-color: #00e0ff; /* Hintergrundfarbe */
            border: 4px solid #000000; /* Rand */
            padding: 8px; /* Innenabstand */
            text-align: center; /* Zentrierung */
            font-size: 20px; /* Schriftgröße */
        }

        /* Liste der Symbole in einer Formel */

        p.Formel {
            font-family: monospace; /* Zeichensatz */
            font-size: 14px; /* Schriftgröße */
            font-weight: normal; /* Schrift normal */
        }

        /* Eingerahmte Definition */

        div.Def {
            margin-left: auto; /* Zentrierung */
            margin-right: auto; /* Zentrierung */
            padding: 10px; /* Innenabstand */
            background-color: #80ffa0; /* Hintergrundfarbe */
            border: 8px double #000000; /* Rand */
            font-size: 18px; /* Schriftgröße */
        }

        /* Eingerahmter Satz */

        div.Satz {
            margin-left: auto; /* Zentrierung */
            margin-right: auto; /* Zentrierung */
            padding: 10px; /* Innenabstand */
            //background-color: #ff80a0; /* Hintergrundfarbe */
            //border: 8px double #000000; /* Rand */
            font-size: 18px; /* Schriftgröße */
        }

        /* Logo mit Link zum Inhaltsverzeichnis */

        div#Index {
            width: 170px;
            margin: 20px auto 20px auto;
            border: 5px double #000000;
            background-color: silver;
        }

        div#Index1 {
            padding: 12px;
            background-color: #ffff00;
            border: 1px solid #000000;
            text-align: center;
        }

        div#Index2 {
            padding: 8px;
            background-color: #ffff00;
            border: 1px solid #000000;
            text-align: center;
            font-size: 16px;
            font-weight: bold;
            color: #0000ff;
        }

        /* Absatz für URL usw. */

        p.Ende {
            font-size: 10pt; /* Schriftgröße */
        }

        /*-------------------------------------------------------------------------------------------------
          Vorgaben für Apps
          -------------------------------------------------------------------------------------------------*/

        /* Gesamte App */

        div#total {
            position: relative;
            margin-top: 20px; /* Abstand nach oben */
            margin-left: auto;
            margin-right: auto; /* Waagrechte Zentrierung */
        }

        /* Zeichenfläche */

        div#canvas {
            position: absolute;
            background-color: #ffff00; /* Hintergrundfarbe */
            border: 1px solid #000000; /* Rand */
        }

        /* Schaltfläche */

        div#panel, div#panel1, div#panel2 {
            position: absolute;
            background-color: lightsteelblue; /* Hintergrundfarbe */
            border: 1px solid #000000; /* Rand */
            font-size: 12px; /* Schriftgröße */
            font-weight: bold; /* Fettdruck */
        }

        /* Zeile einer Schaltfläche */

        div#panel div, div#panel1 div, div#panel2 div {
            position: absolute;
        }

        /* Inline-Element einer Schaltfläche */

        div#panel span, div#panel1 span, div#panel2 span {
            position: absolute;
            white-space: nowrap; /* Kein Zeilenumbruch bei Leerzeichen */
            font-family: sans-serif;
            font-size: 12px;
        }

        /* Schaltknopf */

        button {
            height: 30px; /* Höhe */
            border-radius: 0px; /* Abgerundete Ecken verhindern */
            margin-left: 10px; /* Abstand vom linken Rand */
            font-family: sans-serif; /* Schriftart */
            font-size: 12px; /* Schriftgröße */
            font-weight: bold; /* Fettdruck */
        }

        /* Optionsfeld */

        input[type="checkbox"] {
            margin-left: 10px; /* Abstand vom linken Rand */
            border-radius: 0px; /* Abgerundete Ecken verhindern */
        }

        /* Radiobutton */

        input[type="radio"] {
            margin-left: 10px; /* Abstand vom linken Rand */
        }

        /* Text für Optionsfeld oder Radiobutton */

        label {
            margin-left: 5px; /* Abstand zum Optionsfeld bzw. Radiobutton */
            vertical-align: 2px; /* Kleine Korrektur der Höhe */
        }

        /* Eingabefeld */

        input[type="text"] {
            position: absolute;
            padding-left: 2px; /* Innenabstand links */
            height: 14px; /* Höhe */
            border-radius: 0px; /* Abgerundete Ecken verhindern */
            font-family: sans-serif; /* Schriftart */
            font-size: 12px; /* Schriftgröße */
            font-weight: bold; /* Fettdruck */
        }

        /* Auswahlfeld */

        select {
            position: absolute;
            top: -2px; /* Kleine Korrektur der Höhe */
            left: 10px; /* Abstand zum linken Rand */
            height: 20px; /* Höhe */
            border-radius: 0px; /* Abgerundete Ecken verhindern */
            font-family: sans-serif; /* Schriftart */
            font-size: 12px; /* Schriftgröße */
            font-weight: bold; /* Fettdruck */
        }

        /* Schieberegler */

        input[type="range"] {
            position: absolute;
            left: 10px;
        }

        /* Textbereich */

        textarea {
            position: absolute;
            padding: 3px; /* Innenabstand */
            left: 10px; /* Abstand zum linken Rand */
            border-radius: 0px; /* Abgerundete Ecken verhindern */
            font-family: sans-serif; /* Schriftart */
            font-size: 12px; /* Schriftgröße */
            font-weight: bold; /* Fettdruck */
        }


    </style>
    <style type="text/css">
        div#total { width: 740px; height: 440px; }
        div#canvas { width: 440px; height: 440px; }
        div#panel { left: 440px; width: 300px; height: 440px; }
        input[type="text"] { left: 150px; width: 80px; }
        input[type="range"] { left: 10px; width: 280px; }
        input[type="radio"] { left: 10px; }
        select { left: 150px; width: 140px; }
        .pos1 { left: 10px; }
        .pos2 { left: 150px; }
        .pos3 { left: 255px; }
    </style>

    <script type='text/javascript'>
        var text01 = "Wavelength:";
        var text02 = "Width of slit:";
        var text03 = "Angle:";
        var text04 = "Maxima:";
        var text05 = "Minima:";
        var text06 = "Relative intensity:";
        var text07 = "Diffraction pattern";
        var text08 = "Intensity profile";

        var author = "W. Fendt 2003";

        // Symbole und Einheiten:

        var decimalSeparator = ".";                                // Dezimaltrennzeichen (Komma/Punkt)

        var nanometer = "nm";
        var degree = "&deg;";

        // Texte in Unicode-Schreibweise:

        var symbolOrder = "k";                                     // Symbol für Ordnung eines Maximums oder Minimums
        var degreeUnicode = "\u00B0";

        var colorBackground1 = "#404040";                          // Hintergrundfarbe Versuchsaufbau
        var colorBackground2 = "#ffff00";                          // Hintergrundfarbe Versuchsergebnis
        var colorSingleSlit = "#808080";                           // Farbe für Einfachspalt

        // Sonstige Konstanten:

        var DEG = Math.PI/180;                                     // 1 Grad (Bogenmaß)
        var MAX = 90;                                              // Maximaler Winkel (Gradmaß)
        var RAD = 200;                                             // Radius Beobachtungsschirm
        var FONT = "normal normal bold 12px sans-serif";           // Zeichensatz

        // Attribute:

        var canvas, ctx;                                           // Zeichenfläche, Grafikkontext
        var width, height;                                         // Abmessungen der Zeichenfläche (Pixel)
        var ip1, ip2, ip3;                                         // Eingabefelder
        var sl1, sl2, sl3;                                         // Schieberegler
        var ch1, ch2;                                              // Auswahlfelder
        var op;                                                    // Ausgabefeld
        var rb1, rb2;                                              // Radiobuttons

        var uM, vM;                                                // Ursprung (Pixel)
        var lambda;                                                // Wellenlänge (m)
        var b;                                                     // Spaltbreite (m)
        var alpha;                                                 // Winkel (Bogenmaß)
        var minAlpha;                                              // Winkel für verdeckten Teil des Beobachtungsschirms (Bogenmaß)
        var theta, phi;                                            // Azimut- und Höhenwinkel (Bogenmaß)
        var a1, a2, b1, b2, b3;                                    // Koeffizienten für Projektion
        var poly1, poly2, poly3, slit;                             // Arrays für Polygonecken

        // Element der Schaltfläche (aus HTML-Datei):
        // id ..... ID im HTML-Befehl
        // text ... Text (optional)

        function getElement (id, text) {
            var e = document.getElementById(id);                     // Element
            if (text) e.innerHTML = text;                            // Text festlegen, falls definiert
            return e;                                                // Rückgabewert
        }

        // Start:

        function start () {
            canvas = getElement("cv");                               // Zeichenfläche
            width = canvas.width; height = canvas.height;            // Abmessungen (Pixel)
            ctx = canvas.getContext("2d");                           // Grafikkontext
            getElement("ip1a",text01);                               // Erklärender Text (Wellenlänge)
            ip1 = getElement("ip1b");                                // Eingabefeld (Wellenlänge)
            getElement("ip1c",nanometer);                            // Einheit (Wellenlänge)
            sl1 = getElement("sl1");                                 // Schieberegler (Wellenlänge)
            getElement("ip2a",text02);                               // Erklärender Text (Spaltbreite)
            ip2 = getElement("ip2b");                                // Eingabefeld (Spaltbreite)
            getElement("ip2c",nanometer);                            // Einheit (Spaltbreite)
            sl2 = getElement("sl2");                                 // Schieberegler (Spaltbreite)
            getElement("ip3a",text03);                               // Erklärender Text (Winkel)
            ip3 = getElement("ip3b");                                // Eingabefeld (Winkel)
            getElement("ip3c",degree);                               // Einheit (Winkel)
            sl3 = getElement("sl3");                                 // Schieberegler (Winkel)
            getElement("ch1a",text04);                               // Erklärender Text (Maxima)
            ch1 = getElement("ch1b");                                // Auswahlfeld (Maxima)
            getElement("ch2a",text05);                               // Erklärender Text (Minima)
            ch2 = getElement("ch2b");                                // Auswahlfeld (Minima)
            getElement("op1a",text06);                               // Erklärender Text (relative Intensität)
            op = getElement("op1b");                                 // Ausgabefeld (relative Intensität)
            rb1 = getElement("rb1");                                 // Radiobutton (Beugungsmuster)
            getElement("lb1",text07);                                // Erklärender Text (Beugungsmuster)
            rb2 = getElement("rb2");                                 // Radiobutton (Intensitätsverteilung)
            getElement("lb2",text08);                                // Erklärender Text (Intensitätsverteilung)
            rb1.checked = true;                                      // Zunächst Beugungsmuster ausgewählt
            getElement("author",author);                             // Autor (und Übersetzer)

            uM = 210; vM = 200;                                      // Ursprung (Pixel)
            lambda = 600*1e-9;                                       // Startwert Wellenlänge (m)
            b = 1000*1e-9;                                           // Startwert Spaltbreite (m)
            alpha = 0;                                               // Startwert Winkel (Bogenmaß)
            theta = 200*DEG; phi = 40*DEG;                           // Azimut- und Höhenwinkel (Bogenmaß)
            calcCoeff();                                             // Koeffizienten für Projektion berechnen
            setPolygons();                                           // Arrays für Polygonecken vorbereiten
            updateInput(true,true,true);                             // Eingabefelder aktualisieren
            reaction(true);                                          // Berechnungen, Ausgabe, Zeichnen

            ip1.onkeydown = reactionEnter;                           // Reaktion auf Enter-Taste (Eingabe Wellenlänge)
            ip2.onkeydown = reactionEnter;                           // Reaktion auf Enter-Taste (Eingabe Spaltbreite)
            ip3.onkeydown = reactionEnter;                           // Reaktion auf Enter-Taste (Eingabe Winkel)
            sl1.onchange = reactionSlider1;                          // Reaktion auf Schieberegler (Wellenlänge)
            sl1.onclick = reactionSlider1;
            sl1.oninput= reactionSlider1; // Reaktion auf Schieberegler (Wellenlänge)
            sl2.onchange = reactionSlider2;                          // Reaktion auf Schieberegler (Spaltbreite)
            sl2.onclick = reactionSlider2;
            sl2.oninput= reactionSlider2; // Reaktion auf Schieberegler (Spaltbreite)
            sl3.onchange = reactionSlider3;                          // Reaktion auf Schieberegler (Winkel)
            sl3.onclick = reactionSlider3;
            sl3.oninput= reactionSlider3; // Reaktion auf Schieberegler (Winkel)
            ch1.onchange = reactionSelect1;                          // Reaktion auf Auswahlfeld (Maximum)
            ch1.onclick = reactionSelect1;                           // Reaktion auf Auswahlfeld (Maximum)
            ch2.onchange = reactionSelect2;                          // Reaktion auf Auswahlfeld (Minimum)
            ch2.onclick = reactionSelect2;                           // Reaktion auf Auswahlfeld (Minimum)
            rb1.onclick = reactionRadio;                             // Reaktion auf Radiobutton (Beugungsmuster)
            rb2.onclick = reactionRadio;                             // Reaktion auf Radiobutton (Intensitätsverteilung)
        } // Ende start

        // Neuer Eintrag in Auswahlfeld:
        // ch ... Auswahlfeld
        // w .... Winkel (Bogenmaß)
        // k .... Ordnung des Maximums oder Minimums

        function addNewOption (ch, w, k) {
            if (isNaN(w)) return;                                    // Falls Winkel nicht definiert, abbrechen
            var s = ToString(w/DEG,1,true)+degreeUnicode;            // Zeichenkette (Winkel im Gradmaß)
            if (k != 0) s += " ("+symbolOrder+" = "+k+")";           // Ordnung in Klammer hinzufügen
            var o = document.createElement("option");                // Neues option-Element
            o.text = s;                                              // Text übernehmen
            ch.add(o);                                               // Element zum Auswahlfeld hinzufügen
        }

        // Reaktion auf Tastendruck (nur auf Enter-Taste):
        // Seiteneffekt lambda, b, alpha

        function reactionEnter (e) {
            if (e.key && String(e.key) == "Enter"                    // Falls Entertaste (Firefox/Internet Explorer) ...
                || e.keyCode == 13)                                      // Falls Entertaste (Chrome) ...
                reaction(true);                                        // Daten übernehmen, rechnen, Ausgabe, neu zeichnen
        }

        // Reaktion auf Schieberegler für Wellenlänge:
        // Seiteneffekt lambda, b, alpha

        function reactionSlider1 () {
            lambda = (38+Number(sl1.value))*1e-8;                    // Wellenlänge (m)
            updateInput(true,false,false);                           // Eingabefeld aktualisieren
            reaction(true);                                          // Daten übernehmen, rechnen, Ausgabe, neu zeichnen
        }

        // Reaktion auf Schieberegler für Spaltbreite:
        // Seiteneffekt lambda, b, alpha

        function reactionSlider2 () {
            b = (5+Number(sl2.value))*1e-7;                          // Spaltbreite (m)
            updateInput(false,true,false);                           // Eingabefeld aktualisieren
            reaction(true);                                          // Daten übernehmen, rechnen, Ausgabe, neu zeichnen
        }

        // Reaktion auf Schieberegler für Winkel:
        // Seiteneffekt lambda, b, alpha

        function reactionSlider3 () {
            alpha = Number(sl3.value)*DEG;                           // Winkel (Bogenmaß)
            updateInput(false,false,true);                           // Eingabefeld aktualisieren
            reaction(true);                                          // Daten übernehmen, rechnen, Ausgabe, neu zeichnen
        }

        // Reaktion auf Auswahlfeld für Maxima:
        // Seiteneffekt lambda, b, alpha

        function reactionSelect1 () {
            var k = ch1.selectedIndex;                               // Ordnung des Maximums
            alpha = maximum(k);                                      // Winkel (Bogenmaß)
            updateInput(false,false,true);                           // Eingabefeld aktualisieren
            reaction(false);                                         // Daten übernehmen, rechnen, Ausgabe, neu zeichnen
        }

        // Reaktion auf Auswahlfeld für Minima:
        // Seiteneffekt lambda, b, alpha

        function reactionSelect2 () {
            var k = ch2.selectedIndex+1;                             // Ordnung des Minimums
            alpha = Math.asin(k*lambda/b);                           // Winkel (Bogenmaß)
            updateInput(false,false,true);                           // Eingabefeld aktualisieren
            reaction(false);                                         // Daten übernehmen, rechnen, Ausgabe, neu zeichnen
        }

        // Reaktion auf Radiobuttons:
        // Seiteneffekt lambda, d, alpha

        function reactionRadio () {
            reaction(false);                                         // Daten übernehmen, rechnen, Ausgabe, neu zeichnen
        }

        // Umwandlung einer Zahl in eine Zeichenkette:
        // n ..... Gegebene Zahl
        // d ..... Zahl der Stellen
        // fix ... Flag für Nachkommastellen (im Gegensatz zu gültigen Ziffern)

        function ToString (n, d, fix) {
            var s = (fix ? n.toFixed(d) : n.toPrecision(d));         // Zeichenkette mit Dezimalpunkt
            if (n == 1000) s = "1000";                               // Ausnahme, um "1,00e+3" zu verhindern
            return s.replace(".",decimalSeparator);                  // Eventuell Punkt durch Komma ersetzen
        }

        // Eingabe einer Zahl
        // ef .... Eingabefeld
        // d ..... Zahl der Stellen
        // fix ... Flag für Nachkommastellen (im Gegensatz zu gültigen Ziffern)
        // min ... Minimum des erlaubten Bereichs
        // max ... Maximum des erlaubten Bereichs
        // Rückgabewert: Zahl oder NaN

        function inputNumber (ef, d, fix, min, max) {
            var s = ef.value;                                        // Zeichenkette im Eingabefeld
            s = s.replace(",",".");                                  // Eventuell Komma in Punkt umwandeln
            var n = Number(s);                                       // Umwandlung in Zahl, falls möglich
            if (isNaN(n)) n = 0;                                     // Sinnlose Eingaben als 0 interpretieren
            if (n < min) n = min;                                    // Falls Zahl zu klein, korrigieren
            if (n > max) n = max;                                    // Falls Zahl zu groß, korrigieren
            ef.value = ToString(n,d,fix);                            // Eingabefeld eventuell korrigieren
            return n;                                                // Rückgabewert
        }

        // Gesamte Eingabe:
        // Seiteneffekt lambda, b, alpha, Wirkung auf Eingabefelder und Schieberegler

        function input () {
            lambda = 1e-9*inputNumber(ip1,0,true,380,780);           // Wellenlänge (nm -> m)
            b = 1e-9*inputNumber(ip2,0,true,500,5000);               // Spaltbreite (nm -> m)
            alpha = DEG*inputNumber(ip3,1,true,0,90);                // Winkel (Gradmaß -> Bogenmaß)
            updateSliders();                                         // Schieberegler aktualisieren
        }

        // Aktualisierung der Eingabefelder:
        // i1 ... Flag für Aktualisierung der Wellenlänge
        // i2 ... Flag für Aktualisierung der Spaltbreite
        // i3 ... Flag für Aktualisierung des Winkels

        function updateInput (i1, i2, i3) {
            if (i1) ip1.value = ToString(1e9*lambda,0,true);         // Wellenlänge (nm)
            if (i2) ip2.value = ToString(1e9*b,0,true);              // Spaltbreite (nm)
            if (i3) ip3.value = ToString(alpha/DEG,1,true);          // Winkel (Grad)
        }

        // Aktualisierung der Schieberegler:

        function updateSliders () {
            sl1.value = Math.round(1e8*lambda-38);                   // Schieberegler Wellenlänge
            sl2.value = Math.round(1e7*b-5);                         // Schieberegler Spaltbreite
            sl3.value = Math.round(alpha/DEG);                       // Schieberegler Winkel
        }

        // Auswahlfelder für Maxima und Minima aktualisieren:

        function updateMaxMin () {
            while (ch1.length > 0) ch1.remove(0);                    // Liste der Maxima leeren
            addNewOption(ch1,0,0);                                   // Maximum 0. Ordnung hinzufügen
            var maxK = Math.floor(b/lambda+0.5);                     // Maximale Ordnung eines Maximums (eventuell etwas zu groß)
            for (var k=1; k<=maxK; k++) {                            // Für alle Maxima ab 1. Ordnung ...
                var w = maximum(k);                                    // Winkel (Bogenmaß)
                if (w < 0) break;                                      // Bei sinnlosem Wert abbrechen
                addNewOption(ch1,w,k);                                 // Neuen Eintrag zur Liste hinzufügen
            }
            ch1.selectedIndex = 0;                                   // Maximum 0. Ordnung auswählen
            while (ch2.length > 0) ch2.remove(0);                    // Liste der Minima leeren
            maxK = Math.floor(b/lambda);                             // Maximale Ordnung eines Minimums
            for (k=1; k<=maxK; k++)                                  // Für alle Minima ...
                addNewOption(ch2,Math.asin(Math.min(k*lambda/b,1)),k); // Neuen Eintrag zur Liste hinzufügen
            ch2.selectedIndex = 0;                                   // Minimum 1. Ordnung auswählen
        }

        // Aktualisierung des Ausgabefelds:

        function updateOutput () {
            op.innerHTML = ToString(intensity(alpha),4,true);        // Relative Intensität
        }

        // Eingabe, Berechnungen, Ausgabe, neu zeichnen:
        // mm ... Flag für Aktualisierung der Auswahlfelder für Maxima/Minima
        // Seiteneffekt lambda, b, alpha

        function reaction (mm) {
            input();                                                 // Eingabe
            if (mm) updateMaxMin();                                  // Gegebenenfalls Auswahlfelder für Maxima/Minima aktualisieren
            updateOutput();                                          // Ausgabe aktualisieren
            updateSlit();                                            // Polygonecken für Spalt aktualisieren
            paint();                                                 // Neu zeichnen
        }

        //-------------------------------------------------------------------------------------------------

        // Koeffizienten für Projektion:
        // Seiteneffekt a1, a2, b1, b2, b3

        function calcCoeff () {
            a1 = -Math.sin(theta); a2 = Math.cos(theta);
            b1 = -Math.sin(phi)*a2; b2 = Math.sin(phi)*a1; b3 = Math.cos(phi);
        }

        // Berechnung der waagrechten Bildschirmkoordinate:
        // x, y, z ... Räumliche Koordinaten

        function screenU (x, y) {
            return uM+a1*x+a2*y;
        }

        // Berechnung der senkrechten Bildschirmkoordinate:
        // x, y, z ... Räumliche Koordinaten

        function screenV (x, y, z) {
            return vM-b1*x-b2*y-b3*z;
        }

        // Setzen einer Polygonecke:
        // p ......... Array für Polygonecken
        // i ......... Index der Ecke
        // x, y, z ... Räumliche Koordinaten

        function setPoint (p, i, x, y, z) {
            p[i] = {u: screenU(x,y), v: screenV(x,y,z)};
        }

        // Aktualisiserung des Spalts:
        // Seiteneffekt slit

        function updateSlit () {
            var c = b/2.4e-6;                                           // Hilfsgröße
            var uu = Math.max(screenU(0,-c),uM+0.5);                    // Ecke rechts unten, waagrechte Koordinate (Pixel)
            var vv = screenV(0,-c,-30);                                 // Ecke rechts unten, senkrechte Koordinate (Pixel)
            slit[0] = {u: uu, v: vv};                                   // Ecke rechts unten
            vv = screenV(0,-c,30);                                      // Ecke rechts oben, senkrechte Koordinate (Pixel)
            slit[1] ={u: uu, v: vv};                                    // Ecke rechts oben
            uu = Math.min(screenU(0,c),uM-0.5);                         // Ecke links oben, waagrechte Koordinate (Pixel)
            vv = screenV(0,c,30);                                       // Ecke links oben, senkrechte Koordinate (Pixel)
            slit[2] = {u: uu, v: vv};                                   // Ecke links oben
            vv = screenV(0,c,-30);                                      // Ecke links unten, waagrechte Koordinate (Pixel)
            slit[3] = {u: uu, v: vv};                                   // Ecke links unten
        }

        // Festlegung der Polygone:
        // Seiteneffekt poly1, poly2, poly3, minAlpha, slit

        function setPolygons () {
            poly1 = new Array(4);                                    // Parallelogramm für Einfachspalt
            setPoint(poly1,0,0,50,50);                               // Ecke links oben
            setPoint(poly1,1,0,-50,50);                              // Ecke rechts oben
            setPoint(poly1,2,0,-50,-50);                             // Ecke rechts unten
            setPoint(poly1,3,0,50,-50);                              // Ecke links unten
            poly2 = new Array(4*MAX+2);                              // Polygon für Beobachtungsschirm
            for (var i=0; i<=2*MAX; i++) {                           // Für alle Ecken ...
                var w = (i-MAX)*DEG;                                   // Winkel (Bogenmaß)
                var cos = RAD*Math.cos(w), sin = RAD*Math.sin(w);      // Trigonometrische Werte
                setPoint(poly2,i,cos,sin,50);                          // Ecke am oberen Rand
                setPoint(poly2,4*MAX+1-i,cos,sin,-50);                 // Entsprechende Ecke am unteren Rand
            }
            minAlpha = Math.atan(a2/a1);                             // Winkel für verdeckten Teil (Bogenmaß)
            var i0 = Math.round(-minAlpha/DEG);                      // Entsprechender Index
            poly3 = new Array((MAX-i0+1)*2);                         // Polygon für verdeckten Teil des Beobachtungsschirms
            for (i=0; i<=MAX-i0; i++) {                              // Für alle Ecken ...
                w = (i-MAX)*DEG;                                       // Winkel (Bogenmaß)
                cos = RAD*Math.cos(w); sin = RAD*Math.sin(w);          // Trigonometrische Werte
                setPoint(poly3,i,cos,sin,50);                          // Ecke am oberen Rand
                setPoint(poly3,2*(MAX-i0)+1-i,cos,sin,-50);            // Entsprechende Ecke am unteren Rand
            }
            slit = new Array(4);                                     // Parallelogramm für Spalt
            updateSlit();                                            // Ecken festlegen
        }

        // Berechnung der relativen Amplitude (Maximalwert 1):
        // x ... Winkel (Bogenmaß)

        function amplitude (x) {
            if (x == 0) return 1;                                    // Rückgabewert für Maximum 0. Ordnung
            var c = Math.PI*b*Math.sin(x)/lambda;                    // Hilfsgröße
            return Math.sin(c)/c;                                    // Rückgabewert
        }

        // Berechnung der relativen Intensität (Maximalwert 1):
        // x ... Winkel (Bogenmaß)

        function intensity (x) {
            var a = amplitude(x);                                    // Relative Amplitude
            return a*a;                                              // Rückgabewert
        }

        // Genaue Berechnung eines Maximums (Intervallschachtelung):
        // k ... Ordnung (0, 1, 2, 3, ...)
        // Rückgabewert: Zugehöriger Winkel im Bogenmaß, bei Misserfolg -1

        function maximum (k) {
            if (k == 0) return 0;                                    // Rückgabewert für Maximum 0. Ordnung
            var  l = k*Math.PI;                                      // Linker Rand des Intervalls
            var r = (k+0.5)*Math.PI;                                 // Rechter Rand des Intervalls
            var m = (l+r)/2;                                         // Mitte des Intervalls
            while (r-l > 1e-10) {                                    // Solange Genauigkeit noch nicht ausreichend ...
                if (Math.tan(m) > m) r = m; else l = m;                // ... Intervall halbieren
                m = (l+r)/2;                                           // Mitte des neuen Intervalls
            }
            if (m*lambda > Math.PI*b) return -1;                     // Misserfolg (Maximum existiert nicht)
            return Math.asin(m*lambda/(Math.PI*b));                  // Normalfall
        }

        // Hilfsroutine: Multiplikation mit 256, Umwandlung in zweistellige Hexadezimalzahl (Zeichenkette)
        // z ... Gegebene Zahl

        function toHex (z) {
            if (z < 0) z = 0;                                        // Negative Zahl korrigieren
            if (z > 1) z = 1;                                        // Zahl über 1 korrigieren
            var n = Math.floor(256*z);                               // Multiplikation mit 256
            var hex = n.toString(16);                                // Umwandlung in Hexadezimalzahl (Zeichenkette)
            if (hex.length < 2) hex = "0"+hex;                       // Falls einstellig, führende Null hinzufügen
            if (hex.length > 2) hex = "ff";                          // Zu große Hexadezimalzahl verhindern
            return hex;                                              // Rückgabewert
        }

        // Berechnung der RGB-Darstellung (Algorithmus von Bruton):
        // lambda ... Wellenlänge (m)
        // relInt ... relative Intensität (0 bis 1, optional, Defaultwert 1)
        // Rückgabewert: Zeichenkette im Format "#rrggbb"

        function rgb (lambda, relInt) {
            lambda *= 1e9;                                           // Umrechnung in nm
            if (relInt == undefined) relInt = 1;                     // Gegebenenfalls Defaultwert für relInt verwenden
            var r1 = 0, g1 = 0, b1 = 0;                              // Rot-, Grün- und Blau-Anteil (jeweils 0 bis 1)
            if (lambda >= 380 && lambda < 440) {
                r1 = (440-lambda)/60; g1 = 0; b1 = 1;
            }
            else if (lambda < 490) {
                r1 = 0; g1 = (lambda-440)/50; b1 = 1;
            }
            else if (lambda < 510) {
                r1 = 0; g1 = 1; b1 = (510-lambda)/20;
            }
            else if (lambda < 580) {
                r1 = (lambda-510)/70; g1 = 1; b1 = 0;
            }
            else if (lambda < 645) {
                r1 = 1; g1 = (645-lambda)/65; b1 = 0;
            }
            else if (lambda <= 780) {
                r1 = 1; g1 = 0; b1 = 0;
            }
            var f = 0;                                               // Faktor für Abschwächung am Rand
            if (lambda >= 380 && lambda < 420)
                f = 0.3+0.7*(lambda-380)/40;
            else if (lambda < 700)
                f = 1;
            else if (lambda <= 780)
                f = 0.3+0.7*(780-lambda)/80;
            var gamma = 0.8;                                         // Exponent
            var r2 = relInt*Math.pow(f*r1,gamma);                    // Rot-Anteil unter Berücksichtigung der Intensität
            var g2 = relInt*Math.pow(f*g1,gamma);                    // Grün-Anteil unter Berücksichtigung der Intensität
            var b2 = relInt*Math.pow(f*b1,gamma);                    // Blau-Anteil unter Berücksichtigung der Intensität
            return "#"+toHex(r2)+toHex(g2)+toHex(b2);                // Rückgabewert
        }

        // Berechnung der RGB-Darstellung (Variante: für kleinere Intensität aufgehellt)
        // lambda ... Wellenlänge (m)
        // relInt ... relative Intensität (0 bis 1, optional, Defaultwert 1)
        // Rückgabewert: Zeichenkette im Format "#rrggbb"

        function rgb2 (lambda, relInt) {
            var i = Math.pow(relInt,1/3);                            // Vergrößerte Intensität
            return rgb(lambda,i);                                    // Rückgabewert
        }

        //-------------------------------------------------------------------------------------------------

        // Neuer Pfad mit Standardwerten:
        // w ... Liniendicke (optional, Defaultwert 1)

        function newPath(w) {
            ctx.beginPath();                                         // Neuer Pfad
            ctx.strokeStyle = "#000000";                             // Linienfarbe schwarz
            ctx.lineWidth = (w ? w : 1);                             // Liniendicke
        }

        // Linie zeichnen:
        // x1, y1 ... Anfangspunkt
        // x2, y2 ... Endpunkt
        // c ........ Farbe (optional, Defaultwert schwarz)
        // w ........ Liniendicke (optional, Defaultwert 1)

        function line (x1, y1, x2, y2, c, w) {
            newPath();                                               // Neuer Grafikpfad (Standardwerte)
            if (w) ctx.lineWidth = w;                                // Liniendicke festlegen, falls angegeben
            if (c) ctx.strokeStyle = c;                              // Linienfarbe festlegen, falls angegeben
            ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);                    // Linie vorbereiten
            ctx.stroke();                                            // Linie zeichnen
        }

        // Pfeil zeichnen:
        // x1, y1 ... Anfangspunkt
        // x2, y2 ... Endpunkt
        // w ........ Liniendicke (optional)
        // Zu beachten: Die Farbe wird durch ctx.strokeStyle bestimmt.

        function arrow (x1, y1, x2, y2, w) {
            if (!w) w = 1;                                           // Falls Liniendicke nicht definiert, Defaultwert
            var dx = x2-x1, dy = y2-y1;                              // Vektorkoordinaten
            var length = Math.sqrt(dx*dx+dy*dy);                     // Länge
            if (length == 0) return;                                 // Abbruch, falls Länge 0
            dx /= length; dy /= length;                              // Einheitsvektor
            var s = 2.5*w+7.5;                                       // Länge der Pfeilspitze
            var xSp = x2-s*dx, ySp = y2-s*dy;                        // Hilfspunkt für Pfeilspitze
            var h = 0.5*w+3.5;                                       // Halbe Breite der Pfeilspitze
            var xSp1 = xSp-h*dy, ySp1 = ySp+h*dx;                    // Ecke der Pfeilspitze
            var xSp2 = xSp+h*dy, ySp2 = ySp-h*dx;                    // Ecke der Pfeilspitze
            xSp = x2-0.6*s*dx; ySp = y2-0.6*s*dy;                    // Einspringende Ecke der Pfeilspitze
            ctx.beginPath();                                         // Neuer Pfad
            ctx.lineWidth = w;                                       // Liniendicke
            ctx.moveTo(x1,y1);                                       // Anfangspunkt
            if (length < 5) ctx.lineTo(x2,y2);                       // Falls kurzer Pfeil, weiter zum Endpunkt, ...
            else ctx.lineTo(xSp,ySp);                                // ... sonst weiter zur einspringenden Ecke
            ctx.stroke();                                            // Linie zeichnen
            if (length < 5) return;                                  // Falls kurzer Pfeil, keine Spitze
            ctx.beginPath();                                         // Neuer Pfad für Pfeilspitze
            ctx.lineWidth = 1;                                       // Liniendicke zurücksetzen
            ctx.fillStyle = ctx.strokeStyle;                         // Füllfarbe wie Linienfarbe
            ctx.moveTo(xSp,ySp);                                     // Anfangspunkt (einspringende Ecke)
            ctx.lineTo(xSp1,ySp1);                                   // Weiter zum Punkt auf einer Seite
            ctx.lineTo(x2,y2);                                       // Weiter zur Spitze
            ctx.lineTo(xSp2,ySp2);                                   // Weiter zum Punkt auf der anderen Seite
            ctx.closePath();                                         // Zurück zum Anfangspunkt
            ctx.fill();                                              // Pfeilspitze zeichnen
        }

        // Weißer Markierungspfeil (20 Pixel lang, nach unten):
        // (x,y) ... Anfangspunkt (Pixel)

        function arrowDown (x, y) {
            ctx.strokeStyle = "#ffffff";                             // Linienfarbe weiß
            arrow(x,y,x,y+20);                                       // Pfeil zeichnen
        }

        // Ausgefülltes Rechteck:
        // x ... Abstand vom linken Rand (Pixel)
        // y ... Abstand vom oberen Rand (Pixel)
        // w ... Breite (Pixel)
        // h ... Höhe (Pixel)
        // c ... Füllfarbe
        // r ... Flag für Rand (optional, Defaultwert false)

        function rectangle (x, y, w, h, c, r) {
            newPath();                                               // Neuer Grafikpfad (Standardwerte)
            ctx.fillStyle = c;                                       // Füllfarbe
            ctx.fillRect(x,y,w,h);                                   // Rechteck ausfüllen
            if (r) ctx.strokeRect(x,y,w,h);                          // Falls gewünscht, Rand zeichnen
        }

        // Ausgefüllter Kreis mit schwarzem Rand:
        // (x,y) ... Mittelpunkt (Pixel)
        // r ....... Radius (Pixel)
        // c ....... Füllfarbe

        function circle (x, y, r, c) {
            newPath();                                               // Neuer Grafikpfad (Standardwerte)
            ctx.fillStyle = c;                                       // Füllfarbe
            ctx.arc(x,y,r,0,2*Math.PI,true);                         // Kreis vorbereiten
            ctx.fill();                                              // Kreis ausfüllen
            ctx.stroke();                                            // Rand zeichnen
        }

        // Polygon zeichnen:
        // p ... Array mit Koordinaten der Ecken
        // c ... Füllfarbe
        // b ... Flag für Rand

        function drawPolygon (p, c, b) {
            newPath();                                               // Neuer Grafikpfad (Standardwerte)
            ctx.fillStyle = c;                                       // Füllfarbe
            ctx.moveTo(p[0].u,p[0].v);                               // Zur ersten Ecke
            for (var i=1; i<p.length; i++)                           // Für alle weiteren Ecken ...
                ctx.lineTo(p[i].u,p[i].v);                             // Linie zum Grafikpfad hinzufügen
            ctx.closePath();                                         // Zurück zum Ausgangspunkt
            ctx.fill();                                              // Polygon ausfüllen
            if (b) ctx.stroke();                                     // Falls gewünscht, Rand zeichnen
        }

        // Linker Teil des Beobachtungsschirms (von vorne gesehen):

        function screenLeft () {
            drawPolygon(poly2,"#000000",true);                       // Ausgefülltes Polygon (schwarz)
            for (var i=-360; i<=360; i++) {                          // Für alle Indizes ...
                var w = i*DEG/4;                                       // Winkel (-90° bis +90°, Abstand 0,25°, Bogenmaß)
                var x = RAD*Math.cos(w), y = RAD*Math.sin(w);          // Räumliche Koordinaten
                var u = screenU(x,y), v = screenV(x,y,0);              // Zugehörige Bildschirmkoordinaten (Pixel)
                var c = rgb2(lambda,intensity(w));                     // RGB-Codierung im Format "#rrggbb"
                line(u,v-1.5,u,v+1.5,c,1.5);                           // Teil des Beugungsmusters
            }
            x = RAD*Math.cos(alpha); y = RAD*Math.sin(alpha);        // Räumliche Koordinaten für Markierungspfeile
            u = screenU(x,y); v = screenV(x,y,35);                   // Zugehörige Bildschirmkoordinaten (Pixel)
            arrowDown(u,v);                                          // Linker Markierungspfeil
            if (-alpha > minAlpha) {                                 // Falls rechter Markierungspfeil sichtbar ...
                u = screenU(x,-y); v = screenV(x,-y,35);               // Bildschirmkoordinaten (Pixel)
                arrowDown(u,v);                                        // Rechter Markierungspfeil
            }
        }

        // Rechter Teil des Beobachtungsschirms (von hinten gesehen):

        function screenRight () {
            drawPolygon(poly3,"#000000",true);                       // Ausgefülltes Polygon (schwarz)
            var x = RAD*Math.cos(minAlpha);                          // x-Koordinate für Grenze des sichtbaren Teils
            var y = RAD*Math.sin(minAlpha);                          // y-Koordinate für Grenze des sichtbaren Teils
            var u = screenU(x,y);                                    // Zugehörige waagrechte Bildschirmkoordinate (Pixel)
            ctx.fillStyle = colorBackground1;                        // Hintergrundfarbe als Füllfarbe
            ctx.fillRect(u,0,10,300);                                // Mögliche Ungenauigkeiten verdecken
        }

        // Strahlen für die Maxima (nach dem Spalt):

        function raysMaxima () {
            var c = rgb(lambda);                                     // RGB-Codierung der Spektralfarbe
            var u = screenU(RAD,0), v = screenV(RAD,0,0);            // Bildschirmkoordinaten Mittelpunkt (Pixel)
            line(uM,vM,u,v,c,2);                                     // Lichtstrahl in der Mitte
            var maxK = Math.floor(b/lambda+0.5);                     // Maximale Ordnung eines Maximums (eventuell etwas zu groß)
            for (var k=1; k<=maxK; k++) {                            // Für alle Maxima ab 1. Ordnung ...
                var w = maximum(k);                                    // Winkel (Bogenmaß)
                if (w < 0) break;                                      // Bei sinnlosem Wert abbrechen
                var x = RAD*Math.cos(w), y = RAD*Math.sin(w);          // Räumliche Koordinaten für linken Lichtstrahl
                u = screenU(x,y); v = screenV(x,y,0);                  // Bildschirmkoordinaten für linken Lichtstrahl (Pixel)
                line(uM,vM,u,v,c,2);                                   // Lichtstrahl links zeichnen
                u = screenU(x,-y); v = screenV(x,-y,0);                // Bildschirmkoordinaten  für rechten Lichtstrahl (Pixel)
                line(uM,vM,u,v,c,2);                                   // Lichtstrahl rechts zeichnen
            }
        }

        // Einfachspalt:

        function singleSlit () {
            drawPolygon(poly1,colorSingleSlit,true);                 // Ausgefülltes Parallelogramm mit Rand
            drawPolygon(slit,"#000000",true);                        // Spalt
        }

        // Lichtstrahl vor dem Spalt:

        function rayBefore () {
            var u = screenU(-200,0), v = screenV(-200,0,0);          // Koordinaten Lichtquelle (Pixel)
            line(uM,vM,u,v,rgb(lambda),4);                           // Lichtstrahl zeichnen
        }

        // Horizontale Achse (Winkel):
        // (u,v) ... Ursprung (Pixel)
        // c ....... Farbe

        function horAxis (u, v, c) {
            ctx.strokeStyle = c;                                     // Farbe übernehmen
            arrow(u,v,u+190,v,1.5);                                  // Waagrechte Achse rechts (Winkel)
            arrow(u,v,u-190,v,1.5);                                  // Waagrechte Achse links (Winkel)
            ctx.textAlign = "center";                                // Textausrichtung zentriert
            for (var i=-3; i<=3; i++) {                              // Für alle Ticks im Abstand 30° ...
                var u0 = u+55*i;                                       // Waagrechte Koordinate (Pixel)
                line(u0,v-3,u0,v+3,c);                                 // Tick zeichnen
                var s = ""+Math.abs(i)*30+degreeUnicode;               // Zeichenkette für Beschriftung
                ctx.fillText(s,u0,v+18);                               // Tick beschriften
            }
        }

        // Beugungsmuster:

        function patternDiffraction () {
            var uM = width/2, vM = 360;                              // Mittelpunkt Beugungsmuster (Pixel)
            var  w = 330;                                            // Breite (Pixel)
            var  pix = w/Math.PI;                                    // Umrechnungsfaktor
            rectangle(20,vM-40,width-40,100,"#000000");              // Hintergrund (schwarz)
            for (var u=uM-w/2; u<=uM+w/2; u++) {                     // Von links nach rechts ...
                var x = (uM-u)/pix;                                    // Winkel (Bogenmaß)
                var c = rgb2(lambda,intensity(x));                     // Farbe
                line(u,vM-1.5,u,vM+1.5,c,1.5);                         // Teil des Beugungsmusters
            }
            var i = alpha*pix;                                       // Aktueller Winkel, umgerechnet in Pixel
            arrowDown(uM-i,vM-30);                                   // Linker Pfeil
            arrowDown(uM+i,vM-30);                                   // Rechter Pfeil
            horAxis(uM,vM+30,"#ffffff");                             // Winkelskala (Grad)
        }

        // Intensitätsverteilung:

        function distributionIntensity () {
            var uM = width/2, vM = 410;                              // Ursprung (Pixel)
            horAxis(uM,vM,"#000000");                                // Winkelskala (Grad)
            arrow(uM,vM+5,uM,vM-100,1.5);                            // Senkrechte Achse (Intensität)
            var w = 330;                                             // Breite (Pixel)
            var pixX = w/Math.PI, pixY = 80;                         // Umrechnungsfaktoren
            var u = uM-w/2;                                          // Waagrechte Koordinate Anfangspunkt (Pixel)
            var x = -Math.PI/2;                                      // Zugehöriger Winkel (-90°)
            var y = intensity(x);                                    // Zugehörige Intensität
            var v = vM-y*pixY;                                       // Senkrechte Koordinate Anfangspunkt (Pixel)
            newPath();                                               // Neuer Grafikpfad (Standardwerte)
            ctx.moveTo(u,v);                                         // Anfangspunkt für Polygonzug
            while (u < uM+w/2) {                                     // Solange rechter Rand noch nicht erreicht ...
                u++;                                                   // Waagrechte Koordinate erhöhen
                x = (u-uM)/pixX;                                       // Winkel (Bogenmaß)
                y = intensity(x);                                      // Relative Intensität
                v = vM-y*pixY;                                         // Senkrechte Koordinate
                ctx.lineTo(u,v);                                       // Linie zum Polygonzug hinzufügen
            }
            ctx.stroke();  	                                       // Polygonzug zeichnen
            var du = pixX*alpha;                                     // Waagrechte Koordinate (relativ zum Ursprung, Pixel)
            var v0 = vM-intensity(alpha)*pixY;                       // Senkrechte Koordinate (Pixel)
            circle(uM+du,v0,2.5,"#ff0000");                          // Markierung für aktuellen Winkel (rechts)
            circle(uM-du,v0,2.5,"#ff0000");                          // Markierung für aktuellen Winkel (links)
        }

        // Grafikausgabe:

        function paint () {
            ctx.fillStyle = colorBackground1;                        // Hintergrundfarbe Versuchsaufbau
            ctx.fillRect(0,0,width,300);                             // Hintergrund ausfüllen
            screenLeft();                                            // Linker Teil des Beobachtungsschirms
            raysMaxima();                                            // Strahlen für die Maxima
            screenRight();                                           // Rechter Teil des Beobachtungsschirms
            singleSlit();                                            // Einfachspalt
            rayBefore();                                             // Lichtstrahl vor dem Doppelspalt
            ctx.fillStyle = colorBackground2;                        // Hintergrundfarbe Versuchsergebnis
            ctx.fillRect(0,300,width,height-300);                    // Hintergrund ausfüllen
            ctx.font = FONT;                                         // Zeichensatz
            if (rb1.checked) patternDiffraction();                   // Beugungsmuster
            else distributionIntensity();                            // Intensitätsverteilung
        }

        document.addEventListener("DOMContentLoaded",start,false); // Nach dem Laden der HTML-Seite Methode start ausführen

    </script>
    <meta content="HTML5 app: Interference of light at a double slit" name="description">
    <meta content="Walter Fendt" name="author">
    <meta content="app, physics, optics, interference, double slit" name="keywords">
</head>

<body>

<h1>Diffraction of Light by a Single Slit</h1>

<div id="total">
    <div id="canvas"><canvas id="cv" width=440 height=440>This browser doesn't support HTML5 canvas!</canvas></div>
    <div id="panel">
        <div style="top: 20px;"><span class="pos1" id="ip1a"></span><input type="text" id="ip1b"><span class="pos3" id="ip1c"></span></div>
        <div style="top: 50px;"><input type="range" min=0 max=40 id="sl1"></div>
        <div style="top: 90px;"><span class="pos1" id="ip2a"></span><input type="text" id="ip2b"><span class="pos3" id="ip2c"></span></div>
        <div style="top: 120px;"><input type="range" min=0 max=45 id="sl2"></div>
        <div style="top: 160px;"><span class="pos1" id="ip3a"></span><input type="text" id="ip3b"><span class="pos3" id="ip3c"></span></div>
        <div style="top: 190px;"><input type="range" min=0 max=90 id="sl3"></div>
        <div style="top: 230px;"><span class="pos1" id="ch1a"></span><select id="ch1b"></select></div>
        <div style="top: 270px;"><span class="pos1" id="ch2a"></span><select id="ch2b"></select></div>
        <div style="top: 310px;"><span class="pos1" id="op1a"></span><span class="pos2" id="op1b"></span></div>
        <div style="top: 340px;"><input type="radio" id="rb1" name="bg" value=""><label for="rb1" id="lb1"></label></div>
        <div style="top: 370px;"><input type="radio" id="rb2" name="bg" value=""><label for="rb2" id="lb2"></label></div>
        <div style="top: 410px;"><span class="pos1" id="author"></span></div>
    </div>
</div>

<div class="Satz" style="width: 600px; margin-top: 20px;">
    <strong>Condition for a minimum:</strong>
    <div><span class="Formel" style="width: 180px; display: block; margin: 15px auto 15px auto;">b sin &alpha; &nbsp;=&nbsp; k &lambda;</span></div>
    <p class="Formel" style="margin-top: 20px;">
        b ... width of slit<br>
        &alpha; ... angle<br>
        k ... order of the minimum (1, 2, 3, ...)<br>
        &lambda; ... wavelength
    </p>
</div>



</body>
</html>
